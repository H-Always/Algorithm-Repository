/**
 * @ClassName: NumRookCaptures
 * @Description: 车的可用捕获量
 * @Author: 余霜
 * @Date: 2020/03/26 11:06
 * @Version: V1.0
 *
 * 在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。
 *
 * 车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。
 *
 * 返回车能够在一次移动中捕获到的卒的数量。
 *  输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
 * 输出：3
 * 解释：
 * 在本例中，车能够捕获所有的卒。
 *
 *输入：[[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
 * 输出：0
 * 解释：
 * 象阻止了车捕获任何卒。
 *输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
 * 输出：3
 * 解释：
 * 车可以捕获位置 b5，d6 和 f5 的卒。
 *
 *提示：
 *
 * board.length == board[i].length == 8
 * board[i][j] 可以是 'R'，'.'，'B' 或 'p'
 * 只有一个格子上存在 board[i][j] == 'R'
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/available-captures-for-rook
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 **/
// 特码的，读题读半天，以为是dfs。写完之后跑了跑例子，例子都没通过，找问题
// 这题出的我真的是醉了，什么叫一次移动？？
// 一次移动不应该是每次移动一个格子吗？？下一次再上下左右移动。合着这题的意思就是上下左右横冲直撞最多只能捕获4个？！
// 现在严重怀疑每日一题的质量，真的水啊
// 思路，找到白棋，然后一条道走到黑，看看途中有没有p，有就加1，没有就走另一条路
// 这题做的，真的有点火，题目写了一堆，结果就这？？
public class NumRookCaptures {

    public int numRookCaptures(char[][] board) {
        // 定义上下左右四个方向,这四个是成对出现的，
        // 比如dx[0],dy[0],就是{i-1,j},代表向左移动
        int[] move_x = {-1, 1, 0, 0};
        int[] move_y = {0, 0, -1, 1};

        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                // 找到白车所在的位置，判断一次就行，因为只出现一次
                if (board[i][j] == 'R') {
                    // 分别判断白车的上、下、左、右四个方向
                    int max = 0;
                    for (int k = 0; k < 4; k++) {
                        int x = i, y = j;
                        while (true) {
                            x += move_x[k];
                            y += move_y[k];
                            if (x < 0 || x == board.length || y < 0 || y == board[0].length || board[x][y] == 'B') {
                                break;
                            }
                            if (board[x][y] == 'p') {
                                max++;
                                break;
                            }
                        }
                    }
                    return max;
                }
            }
        }
        return 0;

    }



//这是深度优先搜索，白棋每次都可以走上下左右的格子，判断有多少可以被捕获
    int max = 0;

    public int numRookCaptures_QAQ(char[][] board) {


        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                 if (board[i][j] == 'R'){
                     board[i][j] = '.';
                     dfs(board,i,j);
                     return max;
                 }

            }
        }

        return 0;
    }


    public int dfs(char[][] board,int i,int j){

        if (i<0||i==board.length)
            return 0;
        if (j<0||j==board[0].length)
            return 0;
        if (board[i][j] == 'B')
            return 0;
        if (board[i][j] == 'p') {
            board[i][j] ='B';
            return max++;
        }


        if (board[i][j] == '.'){
            board[i][j] ='B';
            return dfs(board,i-1,j)+dfs(board,i+1,j)+dfs(board,i,j-1)+dfs(board,i,j+1);
        }


        return 0;
    }


}
